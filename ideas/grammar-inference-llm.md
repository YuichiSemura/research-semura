# LLMによる文法定義ファイル生成（CCFinderSW拡張）

## 研究の概要

CCFinderSWでは「ANTLRの文法定義ファイルから予約語とコメント規則を抜き出して、検出の前処理を行う」というアプローチを採用している。この仕組みを活用し、**LLMがドキュメントのないレガシー言語や方言コードから文法定義ファイルを自動生成する**ことで、レガシーシステム分析のハードルを下げる。

## なぜこの技術が必要か

### リリースノートがある言語には不要

Java、Python、TypeScript等の主要言語は公式ドキュメントやリリースノートが充実しており、LLMがそれを読めば文法定義を生成できる。この技術の出番はない。

### 本当に必要なケース：ドキュメントがない/役に立たないコード

| ケース | 具体例 | なぜドキュメントがないか |
|--------|--------|--------------------------|
| **レガシー言語の方言** | COBOL-85の企業独自拡張、IBM方言、富士通方言 | ベンダー固有仕様、社内規約が混在 |
| **社内DSL** | 金融機関の取引記述言語、製造業の制御コード | そもそも外部公開されていない |
| **死んだ言語の派生** | 古いPL/I、ALGOL派生 | メンテナ不在、資料散逸 |
| **非公式の言語拡張** | プリプロセッサで拡張されたC、マクロ多用コード | 正式仕様に含まれない |

### CCFinderSW論文との一貫性

CCFinderSWの論文背景では、COBOLやFortran等のレガシーシステムにおいて「文法定義ファイルさえ作ればType-2クローンを検出できる」と主張した。しかし現実には：

- **COBOLの方言問題**: 標準COBOLの文法定義はあっても、`EXEC CICS`（IBM固有）や企業ごとの書き方の違いに対応できない
- **Fortranの方言問題**: Fortran 77/90/95/2003/2008 + 各コンパイラ拡張（Intel, GCC, PGI）の組み合わせが多様

→ **「方言」のための文法定義を毎回手作業で作るのは現実的でない**という課題を、LLMで解決する

## 研究の問い

### Q1: LLMは未知言語の文法規則をどの程度正確に推論できるか？

- 予約語の抽出精度
- コメント規則の推論精度
- 文字列リテラル規則の推論精度

### Q2: トークナイザーフィードバックにより文法の精度はどの程度改善するか？

- 一発生成 vs フィードバックループありの精度比較
- 収束までに必要なイテレーション回数
- フィードバックで修正されるエラーのパターン分析

### Q3: 生成された文法でのクローン検出精度は、人手作成の文法と比べてどうか？

- Type-2クローン検出の精度・再現率の比較
- 誤検出/見落としのパターン分析

### Q4: どの程度のソースコード量があれば十分な精度が出るか？

- 必要なサンプルコード量の下限
- 言語の複雑さとの関係

## 提案アプローチ：LLM自律エージェントによる文法生成

### コアアイデア

単なる「LLMに一発で文法を生成させる」のではなく、**トークナイザー結果をフィードバックして文法を洗練する自律エージェント**を構築する。

### なぜフィードバックループが必要か

- 方言コードは多様で、一発で正しい文法を生成するのは困難
- トークナイザーを実行すると「パースできない」「未知トークン」等のエラーが明確にわかる
- エラー情報をLLMに返すことで、文法の修正が可能

### アーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│  Grammar Inference Agent                                     │
│                                                              │
│  ┌──────────┐    ┌──────────────┐    ┌──────────────────┐  │
│  │ 1. 分析  │ →  │ 2. 文法生成  │ →  │ 3. 検証          │  │
│  │ (コード  │    │ (JSON中間    │    │ (トークナイズ    │  │
│  │  読み込み)│    │  表現で出力) │    │  を実行)         │  │
│  └──────────┘    └──────────────┘    └────────┬─────────┘  │
│                                               │             │
│                        ┌──────────────────────┘             │
│                        ↓ エラー/異常があれば                │
│                 ┌──────────────┐                            │
│                 │ 4. 修正     │                            │
│                 │ (エラー分析 │ ─── 収束するまで繰り返し   │
│                 │  → 文法調整)│                            │
│                 └──────────────┘                            │
└─────────────────────────────────────────────────────────────┘
                        ↓ 収束後
              ┌──────────────────┐
              │ CCFinderSWで     │
              │ Type-2クローン   │
              │ 検出を実行       │
              └──────────────────┘
```

### フィードバック信号

| 信号 | 検出方法 | 修正アクション例 |
|------|----------|------------------|
| **パースエラー** | トークナイザーが失敗した行 | その行の構文を分析して文法に追加 |
| **未知トークン** | 識別子でも予約語でもないトークン | 予約語リストに追加 or 特殊構文として認識 |
| **閉じないコメント/文字列** | トークン列の異常 | コメント/文字列規則を修正 |
| **予約語の誤認識** | 明らかに識別子が予約語扱い | 予約語リストから削除 |

### 段階的な研究計画

```
Phase 1: ベースライン
  - LLMに一発で文法生成させる
  - 精度を測定（比較対象）

Phase 2: トークナイザーフィードバック（主要貢献）
  - 上記アーキテクチャを実装
  - フィードバックによる精度改善を評価
  - 収束性・安定性を分析

Phase 3: クローン検出フィードバック（発展研究）
  - クローン検出結果の異常を検知
  - さらなる文法改善にフィードバック
  - （複雑なので Future Work になる可能性あり）
```

## 抽出対象の文法要素

| 要素 | 難易度 | 備考 |
|------|--------|------|
| 予約語 | 比較的簡単 | LLMは予約語を高精度で認識できそう |
| コメント規則 | 簡単 | `//`, `/* */`, `#`, `--` などパターンは限られる |
| 文字列リテラル | 中程度 | `"`, `'`, `` ` ``, `"""` など |
| 識別子規則 | 中程度 | Unicode対応等のエッジケースあり |

## 対象言語・コードの候補

### レガシー言語の方言（主要ターゲット）

- **COBOL方言**: IBM COBOL、富士通COBOL、Micro Focus COBOL、EXEC CICS/SQL埋め込み
- **Fortran方言**: Intel Fortran拡張、GCC拡張、古いベンダー固有構文
- **PL/I**: IBM PL/I、各社の独自拡張
- **RPG**: AS/400のRPG II/III/IV、各バージョンの混在

### 企業固有の内製DSL

- 金融機関の取引記述言語
- 製造業の制御・設定コード
- 古いビルドスクリプト言語（Make拡張、独自シェル等）
- ERPカスタマイズ言語（SAP ABAP方言、Oracle PL/SQL拡張）

### マイグレーション対象のコード

- 「仕様書がないが、クローン検出して整理したい」コード
- ベンダーが倒産/サポート終了したツールのスクリプト
- 20年以上前のプリプロセッサ拡張されたC/C++

## 評価実験の設計案

### 実験1: ベースライン vs フィードバックループ

```
1. 既知言語（Java, Python等）の文法定義を「正解」として保持
2. ソースコードのみからLLMに文法を生成させる
   a) 一発生成（ベースライン）
   b) フィードバックループあり（提案手法）
3. 生成文法 vs 正解文法 でCCFinderSWを実行
4. クローン検出の精度・再現率を比較
```

### 実験2: 方言コードでの実用性評価

```
1. COBOL方言やFortran方言のコードを収集
2. 人手で文法定義を作成（ゴールドスタンダード）
3. 提案エージェントで文法を生成
4. クローン検出の精度を比較
```

### 評価指標

| カテゴリ | 指標 |
|----------|------|
| **文法の精度** | 予約語の適合率・再現率、コメント規則の正確性 |
| **クローン検出** | Type-2クローン検出のF1スコア |
| **フィードバック効果** | イテレーションごとの精度改善率 |
| **収束性** | 収束までのイテレーション回数、安定性 |
| **効率性** | LLM呼び出し回数、総処理時間 |

## 技術的検討事項

### ANTLRの文法定義形式の複雑さへの対処

- 懸念: LLMが正確な.g4ファイルを直接生成できるか不明
- 対策案: 中間表現（JSON等）で出力させ、テンプレートで.g4に変換

```json
{
  "keywords": ["if", "else", "for", "while", ...],
  "line_comment": "//",
  "block_comment": {"start": "/*", "end": "*/"},
  "string_delimiters": ["\"", "'"]
}
```

### エッジケースへの対応

- ネスト可能なコメント（例: D言語の `/+ +/`）
- 複数行文字列（Python `"""`, JavaScript テンプレートリテラル）
- 言語固有の特殊構文

## 強みと新規性

| 観点 | 評価 |
|------|------|
| **新規性** | 文法推論×LLM自律エージェント×クローン検出の組み合わせは新しい |
| **技術的貢献** | トークナイザーフィードバックによる自己改善ループ |
| **実用性** | レガシーシステムのモダナイゼーション現場で実需がある |
| **実現可能性** | 完全な文法ではなく「予約語+コメント規則」に限定すれば現実的 |
| **評価しやすさ** | ベースライン vs 提案手法の比較が明確にできる |
| **強みの活用** | CCFinderSWの開発者としての知見が直接活きる |
| **論文との一貫性** | CCFinderSW論文の「レガシー言語対応」という背景と整合する |

## 関連研究領域

- 文法推論（Grammar Inference / Grammar Induction）
- プログラム合成（Program Synthesis）
- DSL認識・解析

## 次のアクション

- [ ] COBOL/Fortran方言の実態調査（どの程度バリエーションがあるか）
- [ ] レガシーシステムモダナイゼーションの関連研究・事例調査
- [ ] 文法推論の既存研究を調査
- [ ] 小規模実験: COBOL方言コードでLLMに予約語リストを生成させてみる
- [ ] CCFinderSWの文法定義読み込み部分の仕様確認
